# -*- coding: utf-8 -*-
"""Project1_Annimation_20B60130_TranHuuNhatHuy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xdXcl-lz3TUIRyAOU2MwAj_iMtOpwbgq
"""

# Import necessary stuffs.
from IPython.display import clear_output
import time
import random

# Arena's initial stats.
ARENA_HEIGHT = 10;
ARENA_WIDTH = 10;
arena = [[None] * ARENA_WIDTH for _ in range(ARENA_HEIGHT)]; # Populate arena with None value.

# Snake's initial stats.
snake_length_init = 4; # Initial length of snake.
snake_tail_init_x, snake_tail_init_y = (ARENA_HEIGHT - 1, int(ARENA_WIDTH/2) - 1); # Initial location of the tail.
snake_location = [];

# Prey's initial stats.
prey_location_x, prey_location_y = (snake_tail_init_x, snake_tail_init_y); # Initial location of prey, which is at the tail of snake so I can trigger "prey_check == False" and generate new prey.
MAX_PREY = 5; # Number of preys needed to catch to end game.
prey_count = 0;

# Generate blank arena with dots.
def arena_generate():
  for i in range(ARENA_HEIGHT):
    for j in range(ARENA_WIDTH):
      arena[i][j] = '.';

# Generate initial state of snake. The symbol of head is 'A', and body parts (including tail) are '1'.
def snake_generate_origin():
  for i in range(snake_length_init):
    arena[snake_tail_init_x - i][snake_tail_init_y] = 1; # Initial body.
    snake_location.append([snake_tail_init_x - i, snake_tail_init_y]); # Save coordinates of body parts into snake_location as [x, y] type.
  arena[snake_tail_init_x - snake_length_init + 1][snake_tail_init_y] = 'A'; # Initial head.

# Update snake's location and state.
def snake_generate():
  for i in range(len(snake_location)):
    arena[snake_location[i][0]][snake_location[i][1]] = 1;
  arena[snake_location[-1][0]][snake_location[-1][1]] = 'A';

# Check if prey's location falls into snake's body or head in some random cases. "False" if it actually falls, and "True" if it's not (location totally okay).
def prey_check(prey_location_x, prey_location_y):
  if (snake_location.count([prey_location_x, prey_location_y]) > 0):
    return False;
  elif ((prey_location_x == snake_location[-2][0]) or (prey_location_y == snake_location[-2][1])): # I don't want the prey be generated in the same line or column of snake's "neck" (right after the head). This will force the snake to turn 3 times, which is really messy for me to code.
    return False;
  else:
    return True;

# Randomly generate the prey (symbol is 'P'), with location checked by prey_check.
def prey_generate():
  global prey_location_x;
  global prey_location_y;
  prey_location_x, prey_location_y = (snake_location[-1][0], snake_location[-1][1]); # Trigger "prey_check == False" so it will always generate new prey.
  while (prey_check(prey_location_x, prey_location_y) == False):
    prey_location_x = random.randint(0, ARENA_HEIGHT - 1);
    prey_location_y = random.randint(0, ARENA_WIDTH - 1);
  arena[prey_location_x][prey_location_y] = 'P'; # The prey.

# Print the arena with snake, prey included.
def print_arena():
  clear_output(); # Refresh the output screen.
  for i in range(ARENA_HEIGHT):
    for j in range(ARENA_WIDTH):
      print(arena[i][j], end = " ");
    print();

# Simulate the snake's crawling motion, with direction = {'N', 'S', 'W', 'E'} representing {"North", "South", "West", "East"} respectively.
def snake_move(direction):
  head_location = snake_location[-1]; # Take head's location.
  if (direction == 'N'):
    snake_location.append([head_location[0] + 1, head_location[1]]); # Let the adjacent Northern block become new head.
  if (direction == 'S'):
    snake_location.append([head_location[0] - 1, head_location[1]]); # Let the adjacent Southern block become new head.
  if (direction == 'W'):
    snake_location.append([head_location[0], head_location[1] - 1]); # Let the adjacent Western block become new head.
  if (direction == 'E'):
    snake_location.append([head_location[0], head_location[1] + 1]); # Let the adjacent Eastern block become new head.
  head_location = snake_location[-1];
  if (head_location != [prey_location_x, prey_location_y]): # If coordinates of head and prey are different (the snake is still on the way to its prey), this means length of snake is unchanged.
    removed_tail = snake_location.pop(0); # Remove the old tail (second-last body part next to the old tail is now the new tail).
    arena[removed_tail[0]][removed_tail[1]] = '.';
  # So this means when the snake eats its prey (head and prey have same coordinates), the length of snake will increase by 1.

# Snake's auto-navigation towards the prey. I prioritize the directions in this order: N -> S -> E -> W.
def snake_navigation():
  if   (snake_location[-1][0] < prey_location_x): # Prey above head.
    snake_move('N');
  elif (snake_location[-1][0] > prey_location_x): # Prey below head.
    snake_move('S');
  elif (snake_location[-1][1] < prey_location_y): # Prey on the right of head.
    snake_move('E');
  elif (snake_location[-1][1] > prey_location_y): # Prey on the left head.
    snake_move('W');
  else: # Prey is exactly at head (snake is eating!). Do nothing and wait for new prey.
    pass;

# Generate initial state of animation.
arena_generate(); # Areana data.
snake_generate_origin(); # Snake data.
prey_generate(); # Prey data.
print_arena(); # Print everything.
print();
print("SNAKE SIMULATOR LOL"); # Title.
time.sleep(5); # Wait for 5 seconds.
clear_output; # Let's go bois!

# NOW LET'S RUN THE ANIMATION!
while (prey_count < MAX_PREY): # On the way to the KPI.
  while (snake_location[-1] != [prey_location_x, prey_location_y]): # On the way to the prey.
    snake_navigation(); # Navigate the snake and move.
    snake_generate(); # Update snake data.
    print();
    print("SNAKE SIMULATOR LOL"); # Reprint the title.
    print("Prey caught: ", prey_count, "/", MAX_PREY); # Number of prey caught.
    time.sleep(1); # Animation loop interval.
    print_arena(); # Update arena.
  prey_count += 1; # Update number of prey caught.
  prey_generate(); # Randomly generate new prey.
print();
print(MAX_PREY, "preys caught! Game terminated!"); # KPI reached. Stop the game.